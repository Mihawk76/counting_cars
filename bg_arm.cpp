//opencv
#include <opencv2/opencv.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
//#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
//#include <opencv2/video.hpp>
#include <opencv2/video/tracking.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <fstream>
using namespace cv;
using namespace std;
// Global variables
Mat fore;
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
std::vector<std::vector<cv::Point> > contours;
int insideCircle;
int totalObject = 0;
int object[30];
RNG rng(12345);
// Blob Tracking Algorithm 
ofstream data;
ofstream pusat;
Point pusLin[2000];
Point movingObject[2000];
int boundary = 400;
//float pusLinY[2000];
//Put Var in image
string text = "Funny text inside the box";
int fontFace = FONT_HERSHEY_PLAIN;
double fontScale = 2;
int thickness = 1;

int countPusLin;
int countMovingObject;
int keyboard; //input from keyboard
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bs {-vid <video filename>|-img <image filename>}"                         << endl
    << "for example: ./bs -vid video.avi"                                           << endl
    << "or: ./bs -img /data/images/1.png"                                           << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}
int main(int argc, char* argv[])
{
    data.clear();
    data.open("data.log",ios::out);
    pusat.clear();
    pusat.open("pusat.log",ios::out);	
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    //create GUI windows
    //namedWindow("Frame");
    //namedWindow("FG Mask MOG 2");
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[2]);
    }
    else if(strcmp(argv[1], "-img") == 0) {
        //input data coming from a sequence of images
        processImages(argv[2]);
    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}
void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        //imshow("Frame", frame);
        //imshow("FG Mask MOG 2", fgMaskMOG2);
	cv::erode(fgMaskMOG2,fore,cv::Mat());
	cv::dilate(fore,fore,cv::Mat());
	//imshow("Fore", fore);
	
	cv::findContours( fore, // binary input image 
                               contours, // vector of vectors of points
                               CV_RETR_EXTERNAL, // retrieve only external contours
                               CV_CHAIN_APPROX_NONE); // detect all pixels of each contour
 	//printf("Counter size is %lu\n", contours.size());
	cv::drawContours( frame, // draw contours here
                                  contours, // draw these contours
                                  -1, // draw all contours
                                  cv::Scalar(0,0,255), // set color
                                  2); // set thickness
	//imshow("Frame",frame);
	/// Approximate contours to polygons + get bounding rects and circles
  	vector<vector<Point> > contours_poly( contours.size() );
	vector<Rect> boundRect( contours.size() );
	vector<Point2f>center( contours.size() );
  	vector<float>radius( contours.size() );
	
	data << "# of contour size: " << contours.size() << endl ;
	for(unsigned int i=0;i<contours.size();i++)
	{
		cout << "# of contour points: " << contours[i].size() << endl ;
		data << "# of contour points: " << contours[i].size() << endl ;
		for(unsigned int j=0;j<contours[i].size();j++)
	     	{
        		cout << "Point(x,y)=" << contours[i][j] << endl;
			data << "Point(x,y)=" << contours[i][j] << endl;
     		}
     		cout << " Area: " << contourArea(contours[i]) << endl;
		data << " Area: " << contourArea(contours[i]) << endl;
	}	
	for( int i = 0; i < contours.size(); i++ )
     	{
		
	    if(contourArea(contours[i]) >= 200)
	    {
		approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
       		boundRect[i] = boundingRect( Mat(contours_poly[i]) );
       		minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );		
		float x = center[i].x;
		float y = center[i].y;
		if (countPusLin <= 2000)
		{
			if ( center[i].x > 10 || center[i].y > 10)
			{
			pusLin[countPusLin] = center[i];
			//pusLinY[countPusLin] = center[i].y;
			countPusLin++;
			if ( center[i].x > 0 && center[i].x < boundary && center[i].y > 0 && center[i].y < boundary)
			{
				movingObject[countMovingObject] = center[i];
				//pusat << "Center of circle " << countMovingObject << ": " << movingObject[countMovingObject].x << "," << movingObject[countMovingObject].y << endl;
				
				countMovingObject++;
			}
			}
			if (countPusLin > 0)
			{
			//line( frame, Point(pusLinX[countPusLin], pusLinY[countPusLin]),  Point(pusLinX[countPusLin-1], pusLinY[countPusLin-1]), Scalar( 0, 0, 0 ), 2, 8 );
			//line( frame, pusLin[countPusLin-1] , pusLin[countPusLin], Scalar( 0, 0, 0 ), 2, 8 );
			}
		}
		data << "Center of Rectangle " << i << ": " << x << "," << y << endl;
		//pusat << "Center of Rectangle " << i << ": " << x << "," << y << endl;
		cout << "Center of Rectangle " << i << ": " << x << "," << y << endl;
		if ( x < 100 && x > 0 && y < 100 && y > 0 )
		{
			insideCircle++;
			//pusat << "Di dalam linkaran kali ke " << insideCircle << "coordinat: " << x << "," << y << endl;
		}
	    }
		/*
		if(contourArea(contours[i]) <= 200)
		{
		//approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
       		//boundRect[i] = boundingRect( Mat(contours_poly[i]) );
       		minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );
		}
		*/
     	}
	//cv::imshow("Background",back);
	//rectangle(frame, bounding_rect,  Scalar(0,255,0),2, 8,0);
	int baseline=0;
	Size textSize = getTextSize(text, fontFace,fontScale, thickness, &baseline);
	baseline += thickness;
	int carIn = 0;
	int count = 0;
	
	//Boundary Box for motion tracking
	line( frame, Point(1, 1) , Point(1,boundary), Scalar( 0, 0, 0 ), 2, 8 );
	line( frame, Point(1, boundary) , Point(boundary,boundary), Scalar( 0, 0, 0 ), 2, 8 );
	line( frame, Point(boundary, boundary) , Point(boundary,0), Scalar( 0, 0, 0 ), 2, 8 );
	line( frame, Point(boundary, 1) , Point(1,1), Scalar( 0, 0, 0 ), 2, 8 );
	//Boundary Box for counting cars
	int yCarMin = 250;
	int yCarMax = 300;
	int yBefore = 200;
	line( frame, Point(1, yCarMin) , Point(boundary,yCarMin), Scalar( 0, 0, 255 ), 2, 8 );
	line( frame, Point(1, yCarMax) , Point(boundary,yCarMax), Scalar( 0, 0, 255 ), 2, 8 );
	line( frame, Point(1, yBefore) , Point(boundary,yBefore), Scalar( 0, 255, 255 ), 2, 8 );
	int totalMovingObject = 0;
	int countObject = 0;	
	while ( totalMovingObject < (countMovingObject-1) )
	{
		//line( frame, movingObject[totalMovingObject] , movingObject[totalMovingObject+1], Scalar( 255, 255, 255 ), 2, 8 );
		int bound = 30;
		if ( (movingObject[totalMovingObject+1].x) < ((movingObject[totalMovingObject].x)+bound) && (movingObject[totalMovingObject+1].x) > ((movingObject[totalMovingObject].x)-bound) && (movingObject[totalMovingObject+1].y) < ((movingObject[totalMovingObject].y)+bound) && (movingObject[totalMovingObject+1].y) > ((movingObject[totalMovingObject].y)-bound) ) 
		{
			line( frame, movingObject[totalMovingObject] , movingObject[totalMovingObject+1], Scalar( 0, 0, 0 ), 2, 8 );			//object[totalObject] = countMovingObject + 1;
			//totalObject++;
			//pusat << "object berubah object ke " << (countMovingObject + 1) << endl;
		}
		else
		{
			int loop = 0;
			while ( loop <= 10 )
			{
				if ( (movingObject[totalMovingObject-loop].x) < ((movingObject[totalMovingObject].x)+bound) && (movingObject[totalMovingObject-loop].x) > ((movingObject[totalMovingObject].x)-bound) && (movingObject[totalMovingObject-loop].y) < ((movingObject[totalMovingObject].y)+bound) && (movingObject[totalMovingObject-loop].y) > ((movingObject[totalMovingObject].y)-bound) ) 
				{
					line( frame, movingObject[totalMovingObject] , movingObject[totalMovingObject-loop], Scalar( 0, 0, 0 ), 2, 8 );
					//break;
				}
				loop++;
			}
		}
		if ( (movingObject[totalMovingObject].y) < yCarMax && (movingObject[totalMovingObject].y) > yCarMin && (movingObject[totalMovingObject].x) > 1 && (movingObject[totalMovingObject].x) < boundary )
		{
			int loop = 1;
			
			while ( loop <= 10 )
			{
				if ( (movingObject[totalMovingObject-loop].x) < ((movingObject[totalMovingObject].x)+bound) && (movingObject[totalMovingObject-loop].x) > ((movingObject[totalMovingObject].x)-bound) && (movingObject[totalMovingObject-loop].y) < ((movingObject[totalMovingObject].y)+bound) && (movingObject[totalMovingObject-loop].y) > ((movingObject[totalMovingObject].y)-bound) )
				{
					if ( (movingObject[totalMovingObject-loop].y) < yCarMax && (movingObject[totalMovingObject-loop].y) > yCarMin && (movingObject[totalMovingObject-loop].x) > 1 && (movingObject[totalMovingObject-loop].x) < boundary )
					{
						break;
					}
					if ( (movingObject[totalMovingObject-loop].y) < yCarMin && (movingObject[totalMovingObject-loop].y) > yBefore && (movingObject[totalMovingObject-loop].x) > 1 && (movingObject[totalMovingObject-loop].x) < boundary )
					{
						carIn++;
					}
				}
				loop++;
			}
		}
		totalMovingObject++;
	}
	// then put the text itself
	ostringstream oss;
	oss << "Car that pass " << carIn;
	pusat << "Car that pass " << carIn << endl;
	text = oss.str();
	putText(frame, text, Point(10, 350) , fontFace, fontScale, Scalar( 0, 0, 255 ), thickness, 8);
	//pusat << "Jumlah object yang ada  " << object[0] << endl;
	/// Draw polygonal contour + bonding rects + circles
  	Mat drawing = Mat::zeros( frame.size(), CV_8UC3 );
  	for( int i = 0; i< contours.size(); i++ )
    	{
		Scalar color_1 = Scalar(0,0,0);
       		drawContours( frame, contours_poly, i, color_1, 1, 8, vector<Vec4i>(), 0, Point() );
       		rectangle( frame, boundRect[i].tl(), boundRect[i].br(), color_1, 2, 8, 0 );
       		circle( frame, center[i], (int)radius[i], color_1, 2, 8, 0 );
		
       		Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
       		drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
       		rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );
       		circle( drawing, center[i], (int)radius[i], color, 2, 8, 0 );
		
     	}
	//imshow( "Contours", drawing );
	//imshow( "Final Form", frame );
	Mat im;
	//cv::erode(fgMaskMOG2,fore,cv::Mat());
	//cv::dilate(fore,im,cv::Mat());
	//transisition to blob
    	IplImage image =  frame;
	
	//cvResetImageROI(&image);
    	//cvThreshold(&image, &image, 100, 200, CV_THRESH_BINARY);

    	//cvSetImageROI(&image, cvRect(0, 25, 383, 287));
		
    	
	/*
	IplImage *chB=cvCreateImage(cvGetSize(&image),8,1);
    	cvSplit(&image,chB,NULL,NULL,NULL);
	
	IplImage *labelImg = cvCreateImage(cvGetSize(&image), IPL_DEPTH_LABEL, 1);
    	CvBlobs blobs;
	//unsigned int result = cvLabel(&image, labelImg, blobs);
    	unsigned int result = cvLabel(chB, labelImg, blobs);

    	cvFilterByArea(blobs, 50, 1000);

    	//cvUpdateTracks(blobs, tracks, 5., 10);
    	cvUpdateTracks(blobs, tracks, 10., 5);

    	cvRenderBlobs(labelImg, blobs, &image, &image, CV_BLOB_RENDER_CENTROID|CV_BLOB_RENDER_BOUNDING_BOX);
    	cvRenderTracks(tracks, &image, &image, CV_TRACK_RENDER_ID|CV_TRACK_RENDER_BOUNDING_BOX|CV_TRACK_RENDER_TO_LOG);

    	cvShowImage("test_tracking", &image);
	*/
        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
void processImages(char* fistFrameFilename) {
    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if(frame.empty()){
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }
    //current image filename
    string fn(fistFrameFilename);
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        size_t index = fn.find_last_of("/");
        if(index == string::npos) {
            index = fn.find_last_of("\\");
        }
        size_t index2 = fn.find_last_of(".");
        string prefix = fn.substr(0,index+1);
        string suffix = fn.substr(index2);
        string frameNumberString = fn.substr(index+1, index2-index-1);
        istringstream iss(frameNumberString);
        int frameNumber = 0;
        iss >> frameNumber;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        //imshow("Frame", frame);
        //imshow("FG Mask MOG 2", fgMaskMOG2);
	erode(fore,fgMaskMOG2,cv::Mat());
	dilate(fore,fore,cv::Mat());
	//imshow("Fore", fore);
        //get the input from the keyboard
        keyboard = waitKey( 30 );
        //search for the next image in the sequence
        ostringstream oss;
        oss << (frameNumber + 1);
        string nextFrameNumberString = oss.str();
        string nextFrameFilename = prefix + nextFrameNumberString + suffix;
        //read the next frame
        frame = imread(nextFrameFilename);
        if(frame.empty()){
            //error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}
